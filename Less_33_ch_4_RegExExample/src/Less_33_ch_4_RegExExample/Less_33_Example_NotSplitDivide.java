package Less_33_ch_4_RegExExample;
/*
– Степан, у гостя карета сломалась…
– Вижу, барин. Ось полетела, да спицы менять надо.
– Починить сможешь?
– За день сделаю.
– А за два?
Степан глянул на барина, перевел взгляд на карету:
– Можно и за два.
– А за пять?
Степан задумчиво почесал в затылке:
– Трудновато, барин. Но ежели постараться, можно и за пять…
– А за десять дней?
Степан аж крякнул:
– Ну, барин, тут тогда самому не справиться. Помощник нужен. Хомо сапиенс!
– Бери помощников! – приказал Федяшев и, многозначительно подмигнув, поднялся по ступенькам в дом.

Задача: Не используя метод *.split() разделить строку
на слова и цифры, данные вывести на экран. Воспользоваться
методом *.end().
*/
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Less_33_Example_NotSplitDivide {
    public static void main(String[] args) {
        List<String> baseOfWord = new ArrayList<>();
        // Исходная строка для разделки
        String text = "Вася заработал 5000 рублей, Петя - 7563 рубля, а Маша - 30000 рублей";
        // Обрезаем пробелы по краям, продолжаю запоминать метод *.trim()
        String str = text.trim();
        // Удаляем все знаки препинания
        str = str.replaceAll("\\p{P}", "");
        // Задаем нулевой индекс
        int startInd = 0;
        // Задаем лишний пробел в конце строки, для полного нахождения всех слов
        str += " ";
        /*
        Задаем регулярное выражение для поиска любого количества пробелов подряд.
        Шаг 1. Задаем паттерн.
        */
        Pattern pat = Pattern.compile("\\s+");
        /*
        Задаем строку с которой будет вестись сравнение регулярного выражения
        Шаг 2. Создаем сопоставитель и передаем в него исходную строку.
        */
        Matcher match = pat.matcher(str);
        /*
        Цикл для нахождения всех пробелов в строке методом *.find(), поиск ведется
        последовательно до первого нахождения соответствия регулярному выражению в
        исходной строке и получения true. Следующее вхождения в поиск идет с найденного
        индекса и т.д. до получения false и выхода из цикла.
        */
        while (match.find())
        {
            /*
            Каждое найденное вхождение записываем в строку для вывода на экран
            начиная со стартового индекса и до индекса конца n-го вхождения.
            */
            String value = str.substring(startInd, match.end());
            baseOfWord.add(value);
            // Переназначаем стартовый индекс
            startInd = match.end();

        }
        // Выводим список на экран используя цикл со ссылкой на метод
        baseOfWord.forEach(System.out::println);
    }
}
