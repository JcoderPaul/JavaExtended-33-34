package Less_33_ch_4_RegExExample;

import Less_33_ch_4_RegExExample.MyClasses.BankStatement;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Программа предназначена для парсинга информации из файла
 * формата *.csv, она не универсальна, в данном случае нужно
 * выделить доходы и расходы из банковской выписки
 * 'movementList.csv' и распределить расходы по компаниям
 * оказывающим услуги.
 **/

public class Less_33_Example_ParsingMainApp {
    // Статический путь до файла данных.
    private static final String dataFile =
            "src\\Less_33_ch_4_RegExExample\\FileForParsing\\movementList.csv";
    /*
    В данной выписке умышленно внесены ошибки в цифрах доходов и расходов
    выглядят они так "254,44", поскольку в данной программе разделителем
    выступает символ ',' то лишняя запятая в строке данных вносит неразбериху
    в процессе парсинга.

    Для этого создано регулярное выражение, которое позволяет в исследуемой
    строке, найти ошибочный элемент и заменить его на правильный и только затем
    произвести разбивку строки на элементы.
    */
    private static Pattern patternForCorrection =
            Pattern.compile("\"[0-9]*\\,[0-9]*\"");
    /*
    Данное регулярное выражение создано для поиска и вычленения строки примерного вида
    'RU/CARD2CARD ALFA_MOBILE>MOSCOW' или похожего, для формирования статей затрат по
    поставщикам.
    */
    private static Pattern patternForFineCompany =
            Pattern.compile("[A-Z][A-Za-z\\D]+[0-9|A-Za-z]+[\\D]+[A-Za-z]");

    public static void main(String[] args) {
        // Полная сумма дохода.
        double fullIncome = 0.0;
        // Полные расходы.
        double fullWaste = 0.0;
        // Контрольная сумма полных расходов, для проверки расчетов.
        double controlFullWaste = 0.0;
        /*
        Создается коллекция для работы с данными с помощью метода который возвращает
        уже сокращенный и упорядоченный массив данных (поставщик, доход, расход).
        */
        List <BankStatement> shortStat = loadDataFromFile();
        /*
        Создаем коллекцию для поставщиков услуг, поскольку строки с поставщиками
        периодически повторяются, мы выбираем HashSet, чтобы собрать только
        уникальные названия поставщиков услуг.
        */
        Set<String> serviceProvider = new HashSet<>();
        // Прогоняем коллекцию по всем элементам для получения данных.
        for (int i = 0; i < shortStat.size(); i++)
        {
            // Суммируем общий доход.
            fullIncome = fullIncome + shortStat.get(i).getIncomeDebit();
            // Суммируем общие затраты.
            fullWaste = fullWaste + shortStat.get(i).getOutcomeСredit();
            // Заносим в HashSet названия поставщиков услуг.
            serviceProvider.add(shortStat.get(i).getDescriptionOfOperation());
        }
        // Выводим данные по общим затратам и расходам на экран.
        System.out.println("------------------------------------------------\n" +
                           "Общая сумма дохода : " + fullIncome);
        System.out.println("Общая сумма расходов : " + fullWaste +
                           "\n------------------------------------------------");
        // Выводим на экран данные по каждому поставщику услуг.
        System.out.println("Суммы расходов по организациям : ");
        // Цикл для прохода всего HashSeta.
        for (String nameProvider : serviceProvider)
        {
            double wasteToProvider = 0.0;
            /*
            Перебираем полную первичную коллекцию для выборки
            каждого поставщика услуг в отдельности.
            */
            for (int i = 0; i < shortStat.size(); i++) {
                /*
                Если имя поставщика услуг из общей коллекции List совпадает
                с именем из уникального списка Set, то мы суммируем затраты
                по данному поставщику.
                */
                if (nameProvider.equals(shortStat.get(i).getDescriptionOfOperation())) {
                    wasteToProvider = wasteToProvider + shortStat.get(i).getOutcomeСredit();
                    /*
                    Если имя не совпадает мы продолжаем поиск до полной выборки
                    конкретного имени из коллекции List, таким образом в итоговую
                    сумму затрат мы собираем данные по каждому конкретному поставщику.
                    */
                } else continue;

            }
            // Выводим результат расчетов на экран.
            System.out.println("Общие затраты по '"
                    + nameProvider + "' составили -> "
                    + wasteToProvider);
            controlFullWaste += wasteToProvider;
        }
        /*
        Выводим общие затраты и еще раз посчитанные по
        каждому поставщику отдельно и просуммированные в итоге.
        */
        System.out.println("------------------------------------------------\n" +
                           "Контрольная сумма всех затрат : " + controlFullWaste +
                           "\n------------------------------------------------");
        if(controlFullWaste == fullWaste){
            System.out.println("Данные по затратам совпали!");
        } else {
            System.out.println("Проверьте расчеты!");
        }

    }

    // Блок методов MAIN_APP
    private static List<BankStatement> loadDataFromFile()
    {
        /*
        Для работы программы был создан класс 'BankStatement' для
        создания массива-коллекции 'staff' из объектов несущих сведения
        о поставщиках услуг, затратах и зачислениях на счет.
        */
        List<BankStatement> staff = new ArrayList<>();
        try
        {
            /*
            Заполняем коллекцию строками из файла лежащего по указанному пути.
            При работе используется класс Files и метод .readAllLines(), в
            который передается путь к файлу через класс Paths и его метод .get(),
            запись происходит построчно.
            */
            List<String> lines = Files.readAllLines(Paths.get(dataFile));
            // Удаляем нулевую строку из коллекции, т.к. в ней нет нужных нам данных.
            lines.remove(0);
            /*
            Обходим коллекцию построчно (т.е. элементы коллекции строки),
            для вычленения нужной информации.
            */
            for(String line : lines)
            {
                /*
                Объект класса Matcher позволяет сравнить полученную строку
                и регулярным выражением которое предназначено для поиска
                лишней запятой в цифрах расходов и доходов.
                */
                Matcher matcher = patternForCorrection.matcher(line);
                /*
                Для запуска процесса поиска необходим метод .find(),
                он выкидывает true если поиск в строке прошел успешно
                и false если совпадений не было найдено.
                */
                if (matcher.find()) {
                    /*
                    Если совпадение нашли, то в переменную 'valueRes' заносим
                    ту информацию с которым совпало регулярное выражение. Например,
                    нам нужно найти "245,25" - последовательность, из кавычек,
                    нескольких цифр, запятой, еще нескольких цифр и снова кавычки.
                    */
                    String valueRes = matcher.group();
                    /*
                    Теперь найденную последовательность символов обрабатываем
                    следующим образом, методом *.replaceAll() удаляем из него
                    кавычки, заменив их на пустой символ и запятую меняем на точку.
                    Тогда из, например "245,25" мы можем сделать 245.25
                    */
                    valueRes = valueRes.
                            replaceAll("\"","").
                            replace(",",".");
                    /*
                    Теперь в общей строке, с которой работаем на данный момент
                    (элементом коллекции строк) мы снова находим последовательность
                    цифр обрамленных кавычками и содержащих запятую, и заменяем на
                    обычную последовательность с точкой и без кавычек. Т.е. в общей
                    строке меняем, например "245,25" на 245.25, получив тем самым
                    верную разметку для дальнейшей работы по вычленению данных.
                    */
                    line = matcher.replaceAll(valueRes);
                }
                /*
                До сего момента доходят строки с 8-ю разделительными
                запятыми, методом *.split() мы получаем массив элементов,
                нас интересуют цифры дохода, расхода, и поставщики услуг.
                 */
                String[] fragments = line.split(",");
                if(fragments.length != 8) {
                    /*
                    Если запятых больше 8 - массив будет неверным, в идеале,
                    предыдущие манипуляции с запятыми (исправление ошибок с
                    использованием регулярных выражений) должны решить вопрос.
                    */
                    System.out.println("Wrong line: " + line);
                    continue;
                }
                /*
                При разбиении строки на элементы мы получили 8-мь фрагментов,
                нам нужны последние 3-и, при этом во фрагменте содержащем сведения
                о поставщиках услуг, много лишней для наших нужд информации, нам
                нужны только названия оных.

                Для поиска и вычленения нужной информации, снова применяем регулярное
                выражение описанное выше.

                Создается Matcher, ему передается объект Pattern с методом *.matcher
                (в который в качестве аргумента передается строка для поиска в ней
                того самого искомого шаблонного выражения)
                */
                Matcher matcherForFindCompany =
                        patternForFineCompany.matcher(fragments[5]);
                // Запускаем процесс поиска шаблонной строки.
                matcherForFindCompany.find();
                /*
                Выделяем найденную строку (название поставщика услуг) и перезаписываем
                весь фрагмент, найденной строкой, тем самым оставив лиш название поставщика
                услуг, которое выведется на экран.
                 */
                fragments[5] = matcherForFindCompany.group();
                /*
                Добавляем в List объект класса BankStatement со всеми полученными данными:
                - фрагмент 5 - название поставщика услуг,
                - фрагмент 6 - графа прихода,
                - фрагмент 7 - графа расхода.
                Теперь каждый объект массива содержит всю информацию согласно задания.
                */
                staff.add(new BankStatement(fragments[5],
                                            Double.parseDouble(fragments[6]),
                                            Double.parseDouble(fragments[7])));
            }
        }
        catch (Exception ex) {
            ex.printStackTrace();
        }
        // Возвращаем полученный массив в основной блок main, для работы с ним.
        return staff;
    }
}