******* Class Pattern - Класс Паттерн *******

Пакеты Java:
java.lang.Object
java.util.regex.Pattern

Супер классы и реализованные интерфейсы:
public final class Pattern extends Object implements Serializable;

Регулярное выражение, указанное в виде строки, должно быть сначала скомпилировано
в экземпляр класса Pattern. Полученный шаблон можно затем использовать для создания
объекта Matcher, который может сопоставлять произвольные последовательности символов
с регулярным выражением. Все состояние, связанное с выполнением сопоставления,
находится в 'сопоставителе' - matcher, поэтому многие сопоставители могут использовать
один и тот же шаблон.

Типичная последовательность вызова:
------------------------------------------------------------------------------------------
 Pattern patternOfMine = Pattern.compile("a*b");
 Matcher myMatcherFor = patternOfMine.matcher("aaaaab");
 boolean thereIsMatch = myMatcherFor.matches();
------------------------------------------------------------------------------------------

У класса Pattern определен метод *.matches(). Он удобен тем, что когда регулярное выражение
используется нами только один раз. Этот метод компилирует выражение и сопоставляет с ним
входную последовательность за один вызов. Пример:
------------------------------------------------------------------------------------------
boolean thereIsMatch = Pattern.matches("a*b", "aaaaab");
------------------------------------------------------------------------------------------
Одна строка эквивалентна трем строкам кода приведенным выше, хотя для повторяющихся
совпадений такой синтаксис менее эффективен, поскольку не позволяет повторно использовать
скомпилированный шаблон.

Особенности в многопоточности:
- экземпляры класса Pattern неизменяемы и безопасны для использования несколькими
параллельными потоками;
- экземпляры класса Matcher небезопасны при использовании в многопоточных структурах.

Методы класса Pattern:
- static Pattern compile(String regex) - компилирует заданное регулярное выражение в шаблон,
  где regex- выражение для компиляции;

- static Pattern compile(String regex, int flags) - компилирует данное регулярное выражение
  в шаблон с заданными флагами, regex- выражение для компиляции, flags- флаги соответствия,
  битовая маска, которая может включать CASE_INSENSITIVE, MULTILINE, DOTALL, UNICODE_CASE,
  CANON_EQ, UNIX_LINES, LITERAL, UNICODE_CHARACTER_CLASS и COMMENTS;

- int flags() - возвращает флаги соответствия этого шаблона.

- Matcher matcher(CharSequence input) - создает 'сопоставитель - matcher', который будет
  сопоставлять заданный ввод с этим 'шаблоном - pattern', где input- последовательность
  символов, которая должна быть сопоставлена;

- static boolean matches(String regex, CharSequence input) - компилирует данное 'регулярное
  выражение - regex' и пытается сопоставить с ним заданный 'ввод - input'. Где regex - выражение
  для компиляции, input - последовательность символов, которая должна быть сопоставлена.
  Вызов: Pattern.matches(regex, input);
  Работает точно так же, как выражение: Pattern.compile(regex).matcher(input).matches()

- String pattern() - возвращает регулярное выражение, из которого был скомпилирован текущий шаблон.

- static String	quote(String s) - возвращает литеральную строку шаблона для указанной строки String s.
  Этот метод создает строку, которую можно использовать для генерации шаблона, который в свою очередь
  будет соответствовать String s, как если бы это был буквальный шаблон. Метасимволы или управляющие
  последовательности во входной последовательности не будут иметь специального значения.

- String[] split(CharSequence input) - разбивает заданную входную последовательность на совпадения
  с regex шаблоном (шаблон как разделитель), где input- последовательность символов, которая будет
  разделена. Возвращается массив строк, вычисленный путем разделения входных данных на совпадения
  с текущим шаблоном.

  Пример, на входе метода *.split() input = "boo:and:foo":
  --------------------------------------
    Regex |          Result
  --------------------------------------
      :   |  { "boo", "and", "foo" }
      o   |  { "b", "", ":and:f" }
  --------------------------------------

- String[] split(CharSequence input, int limit) - разбивает заданную входную последовательность на
  совпадения с regex шаблоном (шаблон как разделитель) с использованием предела limit.
  Где параметры:
    - input - последовательность символов, которая будет разделена;
    - limit - Порог результата, как описано выше;
  Метод возвращает: массив строк, вычисленный путем разделения входных данных на совпадения с
                    текущим шаблоном.

  Пример, на входе метода *.split() input = "boo:and:foo":
  ------------------------------------------------
    Regex | Limit |     Result
  ------------------------------------------------
      :   |   2   | { "boo", "and:foo" }
      :   |   5   | { "boo", "and", "foo" }
      :   |  -2   | { "boo", "and", "foo" }
      o   |   5   | { "b", "", ":and:f", "", "" }
      o   |  -2   | { "b", "", ":and:f", "", "" }
      o   |   0   | { "b", "", ":and:f" }
  ------------------------------------------------

- String toString() - возвращает строковое представление regex шаблона.

------------------------------------------------------------------------------------------
Более подробно: https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html